Спасибо за предоставленные файлы! Теперь у меня есть практически вся необходимая информация для подробного анализа и предложения по реализации функционала "МЕМО" для создания резюме по документу.

Подтверждение, что MEMOInterface.tsx аналогичен ChatInterface.tsx, очень помогает. Это означает, что мы можем использовать ChatInterface.tsx как основу для модификаций.

Мы можем приступать к плану по адаптации "МЕМО" под суммирование документов.

Адаптация "МЕМО" для создания резюме по документу
Поскольку "МЕМО" пока полностью дублирует функционал "Chat", наша задача — изменить его так, чтобы вместо диалога он принимал документ (или его часть) и возвращал короткое резюме. Это потребует изменений как во фронтенде, так и в бэкенде.

1. Изменения во Фронтенде (Next.js)
Мы будем ориентироваться на ChatInterface.tsx для создания MEMOInterface.tsx с модификациями.

Файл: src/app/components/MEMO/MEMOInterface.tsx (аналогично ChatInterface.tsx)

Логика:

Ввод: Вместо поля для ввода чат-сообщений (как userInput в ChatInterface), MEMOInterface должен будет предоставлять механизм для выбора документа или ввода его ID/контента для суммирования. Это может быть:

Поле для ввода UUID документа, если документы уже загружены в Weaviate.

Возможность загрузить новый документ (что потребует переиспользования или адаптации логики из IngestionView).

Просто textarea для вставки текста, который нужно суммировать.

Отправка запроса: Вместо sendUserQuery (который отправляет пользовательский запрос в чат), потребуется новая функция (например, sendSummarizeRequest), которая будет вызывать новый API-метод на бэкенде.

Отображение результата: Вместо списка messages (как в ChatInterface), MEMOInterface будет отображать одно полученное резюме. UI должен быть более простым, возможно, textarea или div для вывода.

Удаление ненужного: Уберите элементы, специфичные для чата:

Кнопки "Отправить" и "Обновить" (если не нужны).

Логику currentSuggestions, selectedDocument, selectedChunkScore, если они не относятся к суммированию.

Логику WebSocket-соединения для стриминга сообщений, если суммирование будет происходить через обычный HTTP POST/GET запрос.

Отображение истории сообщений, так как будет только одно резюме.

RAGConfig (опционально): Возможно, конфигурация RAG (Generator, Embedder, Retriever) все еще будет актуальна для суммирования (например, выбор модели Generator). Если да, то ChatConfig можно адаптировать или создать MemoConfig.

2. Изменения в Бэкенде (FastAPI)
Файл: goldenverba/server/api.py

Новый API-эндпоинт: Вам нужно будет добавить новый POST-эндпоинт, который будет принимать запрос на суммирование.

Python

# goldenverba/server/api.py

from goldenverba.server.types import SummarizePayload, SummarizeResponse # <--- ДОБАВЬТЕ ЭТОТ ИМПОРТ

@app.post("/api/summarize") # <--- НОВЫЙ ЭНДПОИНТ
async def summarize_document(payload: SummarizePayload):
    try:
        client = await client_manager.connect(payload.credentials)
        # Вызов менеджера для выполнения суммирования
        summary_text = await manager.weaviate_manager.generate_summary(
            client,
            payload.document_uuid, # или payload.text_content
            payload.rag_config # если нужна конфигурация LLM
        )
        return JSONResponse(
            content={
                "summary": summary_text,
            }
        )
    except Exception as e:
        msg.fail(f"Error during summarization: {e}")
        return JSONResponse(
            content={
                "summary": "Error: Could not generate summary.",
            },
            status_code=500
        )
Файл: goldenverba/server/managers.py

Новая функция в менеджере: В VerbaManager или WeaviateManager (в managers.py) потребуется новая асинхронная функция, которая будет выполнять логику суммирования.

Python

# goldenverba/server/managers.py

# ... внутри класса WeaviateManager (или нового класса SummarizationManager)

async def generate_summary(self, client: WeaviateAsyncClient, document_uuid: str = None, text_content: str = None, rag_config: RAGConfig = None) -> str:
    # Здесь будет логика для получения контента документа (по UUID)
    # или использования text_content напрямую
    if document_uuid:
        # Получаем документ из Weaviate
        # Пример: document = await client.collection.get(document_uuid)
        # document_content = document.properties["content"] # или другое поле
        # Нужно будет реализовать получение контента документа по UUID
        document_content = "Текст документа из Weaviate по UUID " + document_uuid
    elif text_content:
        document_content = text_content
    else:
        raise ValueError("Either document_uuid or text_content must be provided.")

    # Выбираем генератор из rag_config (аналогично тому, как это делается для чата)
    generator_name = rag_config.generator if rag_config else "default_generator_name" # получите актуальное имя генератора
    generator_instance = self.generators[generator_name] # доступ к экземпляру генератора

    # Подготавливаем промпт для суммирования
    prompt = f"Summarize the following document concisely:\n\n{document_content}\n\nSummary:"

    # Используем генератор для создания резюме (без стриминга, если не нужно)
    # Возможно, вам понадобится метод generate_text или адаптировать generate_stream
    # для одноразовой генерации
    summary_response = ""
    # Пример использования генератора:
    async for token_dict in generator_instance.generate_stream(queries=[prompt], context=[], conversation={}):
         summary_response += token_dict.get("content", "")

    return summary_response.strip()
3. Новые Типы Данных
Файл: src/app/types.ts (Критически важен!)

Файл: goldenverba/server/types.py (подразумевается, что он соответствует types.ts)

Вам нужно будет определить новые типы для запроса и ответа на суммирование.

TypeScript

// src/app/types.ts

// Тип для запроса на суммирование
export type SummarizePayload = {
  document_uuid?: string; // ИЛИ
  text_content?: string; // Один из этих двух должен быть
  credentials: Credentials;
  rag_config?: RAGConfig; // Если нужна конфигурация LLM
};

// Тип для ответа суммирования
export type SummarizeResponse = {
  summary: string;
};
И аналогичные Pydantic-модели в goldenverba/server/types.py.

4. Обновление api.ts (фронтенд)
В src/app/api.ts добавьте функцию для вызова нового эндпоинта суммирования:

TypeScript

// src/app/api.ts

// ... (существующие импорты и функции)

import { SummarizePayload, SummarizeResponse, Credentials, RAGConfig } from "./types"; // Обновите импорт

export const sendSummarizeRequest = async (
  payload: SummarizePayload
): Promise<SummarizeResponse | null> => {
  try {
    const host = await detectHost();
    const response = await fetch(`${host}/api/summarize`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error(`Error ${response.status}: ${response.statusText}`);
      const errorData = await response.json();
      console.error("Error details:", errorData);
      return { summary: `Error: ${errorData.summary || "Failed to summarize."}` };
    }

    const data: SummarizeResponse = await response.json();
    return data;
  } catch (error) {
    console.error("Error sending summarize request", error);
    return { summary: `Error: ${error.message || "Network or unexpected error."}` };
  }
};
Шаги для реализации:
Создайте или модифицируйте src/app/components/MEMO/MEMOInterface.tsx:

Возьмите за основу ChatInterface.tsx.

Измените UI для выбора документа/ввода текста и отображения резюме.

Используйте новую функцию sendSummarizeRequest из api.ts.

Обновите src/app/types.ts: Добавьте типы SummarizePayload и SummarizeResponse.

Обновите goldenverba/server/types.py: Создайте соответствующие Pydantic-модели для SummarizePayload и SummarizeResponse.

Измените goldenverba/server/managers.py: Добавьте функцию generate_summary в WeaviateManager (или соответствующий класс) для логики суммирования. Возможно, потребуется адаптация методов генератора для получения единого ответа, а не потока.

Измените goldenverba/server/api.py: Добавьте новый POST-эндпоинт /api/summarize.

Обновите page (1).tsx: Если MEMOInterface.tsx должен отображаться при выборе страницы "MEMO", убедитесь, что page (1).tsx правильно отображает ваш новый компонент, аналогично тому, как он отображает ChatView.

После внесения всех изменений, вам нужно будет пересобрать Docker-образы и перезапустить docker-compose для применения изменений на обоих концах.
