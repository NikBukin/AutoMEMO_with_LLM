1. Фронтенд (React/TypeScript)
page.tsx
Этот файл отвечает за маршрутизацию и отображение различных страниц. Чтобы страница МЕМО была доступна, её нужно правильно интегрировать:

Добавьте условный рендеринг для MEMOView: Убедитесь, что существует блок, который отображает MEMOView при соответствующем значении currentPage. Например:

TypeScript

<div
    className={`${
        currentPage === "MEMO" && production !== "Demo" ? "" : "hidden"
    }`}
>
    <MEMOView
        RAGConfig={RAGConfig}
        setRAGConfig={setRAGConfig}
        credentials={credentials}
        addStatusMessage={addStatusMessage}
        selectedTheme={selectedTheme}
        documentFilter={documentFilter}
        setDocumentFilter={setDocumentFilter}
    />
</div>
Импортируйте MEMOView: Добавьте следующую строку в начале файла:

TypeScript

import MEMOView from "./components/Chat/MEMOView"; // Уточните путь, если он отличается
Обеспечьте навигацию: Должен быть элемент навигации (например, кнопка в Navbar) или логика, которая устанавливает currentPage в "MEMO" при необходимости.

MEMOView.tsx
Этот файл, судя по всему, уже корректно служит контейнером для MEMOInterface и DocumentExplorer. Дополнительных изменений, исходя из представленных фрагментов, не требуется.

MEMOInterface.tsx
Этот компонент является основным интерфейсом для генерации МЕМО. Убедитесь, что функция, отвечающая за отправку запроса на генерацию МЕМО, корректно формирует MemoPayload и вызывает sendMemoRequest из api.ts.

types.ts
В этом файле необходимо определить типы данных для фронтенда, используемые при отправке и получении МЕМО.

Добавьте типы MemoPayload и MemoResponse:

TypeScript

export type MemoPayload = {
  memo_template: string;
  document_uuid?: string | null;
  text_content?: string | null;
  credentials: Credentials;
  rag_config?: RAGConfig | null;
};

export type MemoResponse = {
  memo_text: string;
};
api.ts
Функция sendMemoRequest уже присутствует и, вероятно, корректно отправляет POST-запрос на бэкенд. Убедитесь, что она импортирует MemoPayload и MemoResponse из types.ts.

2. Бэкенд (Python)
types.py
Это самая критическая проблема! Ваш файл types.py пуст, что означает отсутствие необходимых Pydantic моделей для валидации данных на бэкенде.

Восстановите или добавьте Pydantic модели: Необходимо определить следующие классы BaseModel в types.py:

Python

from typing import Literal, Optional
from pydantic import BaseModel

class Credentials(BaseModel):
    deployment: Literal["Weaviate", "Docker", "Local", "Custom"]
    url: str
    key: str

class RAGComponentClass(BaseModel):
    name: str
    selected_component: str
    config: dict

class RAGConfig(BaseModel):
    reader: RAGComponentClass
    chunker: RAGComponentClass
    embedder: RAGComponentClass
    retriever: RAGComponentClass
    generator: RAGComponentClass

class MemoPayload(BaseModel):
    memo_template: str
    document_uuid: Optional[str] = None
    text_content: Optional[str] = None
    credentials: Credentials
    rag_config: Optional[RAGConfig] = None

class MemoResponse(BaseModel):
    memo_text: str
api.py
Этот файл содержит FastAPI эндпоинты.

Убедитесь в импорте MemoPayload и MemoResponse: После исправления types.py, убедитесь, что эти классы правильно импортируются в api.py:

Python

from goldenverba.server.types import MemoPayload, MemoResponse, Credentials, RAGConfig # Добавьте сюда все необходимые импорты
Проверьте логику эндпоинта /api/generate_memo: Убедитесь, что эндпоинт корректно извлекает контекст документа или текстовое содержимое из MemoPayload и передает его в create_memo_with_template из менеджера Weaviate.

managers.py
Этот файл содержит логику взаимодействия с Weaviate и компонентами RAG.

Проверьте методы retrieve_document_content и create_memo_with_template:

Убедитесь, что weaviate_manager содержит метод retrieve_document_content, который может извлекать содержимое документа по его UUID.

Убедитесь, что weaviate_manager содержит метод create_memo_with_template, который принимает клиент Weaviate, шаблон МЕМО, контекст документа и конфигурацию RAG, и возвращает сгенерированный текст МЕМО. Этот метод должен использовать компонент Generator из rag_config для фактической генерации текста.

После внесения этих изменений, ваша система должна начать корректно обрабатывать запросы на формирование МЕМО, используя предоставленный контекст и конфигурацию RAG.
























1. MEMOView.tsx
This component acts as the main view for the MEMO feature. We need to introduce state management for selecting an existing document and potentially for handling new document uploads. The key is to pass the setSelectedDocument and setSelectedChunkScore states from ChatView (your original chat component) to MEMOView so it can interact with the DocumentExplorer.

Here's the modified MEMOView.tsx:

TypeScript

"use client";

import React, { useState } from "react";
import MEMOInterface from "./MEMOInterface"; // Assuming you have MEMOInterface
import DocumentExplorer from "../Document/DocumentExplorer"; // Re-using DocumentExplorer

import {
  Credentials,
  RAGConfig,
  ChunkScore,
  Theme,
  DocumentFilter,
} from "@/app/types";

interface MEMOViewProps {
  selectedTheme: Theme;
  credentials: Credentials;
  addStatusMessage: (
    message: string,
    type: "INFO" | "WARNING" | "SUCCESS" | "ERROR"
  ) => void;
  production: "Local" | "Demo" | "Production";
  currentPage: string;
  RAGConfig: RAGConfig | null;
  setRAGConfig: React.Dispatch<React.SetStateAction<RAGConfig | null>>;
  documentFilter: DocumentFilter[];
  setDocumentFilter: React.Dispatch<React.SetStateAction<DocumentFilter[]>>;
}

const MEMOView: React.FC<MEMOViewProps> = ({
  credentials,
  selectedTheme,
  addStatusMessage,
  production,
  currentPage,
  RAGConfig,
  setRAGConfig,
  documentFilter,
  setDocumentFilter,
}) => {
  const [selectedDocument, setSelectedDocument] = useState<string | null>(null);
  const [selectedChunkScore, setSelectedChunkScore] = useState<ChunkScore[]>(
    []
  );

  return (
    <div className="flex md:flex-row flex-col justify-center gap-3 h-[50vh] md:h-[80vh] ">
      <div
        className={`${selectedDocument ? "hidden md:flex md:w-[45vw]" : "w-full md:w-[45vw] md:flex"}`}
      >
        <MEMOInterface
          addStatusMessage={addStatusMessage}
          production={production}
          credentials={credentials}
          selectedTheme={selectedTheme}
          setSelectedDocument={setSelectedDocument} // Pass setSelectedDocument
          setSelectedChunkScore={setSelectedChunkScore} // Pass setSelectedChunkScore
          currentPage={currentPage}
          RAGConfig={RAGConfig}
          setRAGConfig={setRAGConfig}
          documentFilter={documentFilter}
          setDocumentFilter={setDocumentFilter}
          selectedDocument={selectedDocument} // Pass selectedDocument to MEMOInterface
        />
      </div>

      <div
        className={`${selectedDocument ? "md:w-[55vw] w-full flex" : "hidden md:flex md:w-[55vw]"}`}
      >
        <DocumentExplorer
          addStatusMessage={addStatusMessage}
          credentials={credentials}
          production={production}
          documentFilter={documentFilter}
          setDocumentFilter={setDocumentFilter}
          setSelectedDocument={setSelectedDocument}
          selectedTheme={selectedTheme}
          selectedDocument={selectedDocument}
          chunkScores={selectedChunkScore}
        />
      </div>
    </div>
  );
};

export default MEMOView;
2. MEMOInterface.tsx
This component will be the core of the MEMO generation. It needs to:

Allow users to select an existing document from a dropdown (using documentFilter and selectedDocument).

Provide an input for a memo template.

Display the generated memo.

Integrate with the backend API to send the memo generation request.

We'll add a new state for memoTemplate and memoResult, and modify sendUserMessage to call a new sendMemoRequest API function.

TypeScript

"use client";

import React, { useState, useEffect, useRef } from "react";
import { MdCancel, MdOutlineRefresh } from "react-icons/md";
import { TbPlugConnected } from "react-icons/tb";
import { IoIosSend } from "react-icons/io";
import VerbaButton from "../Navigation/VerbaButton";

import {
  updateRAGConfig,
  fetchDatacount,
  fetchRAGConfig,
  fetchSuggestions,
  fetchLabels,
  sendMemoRequest, // Import the new memo API call
} from "@/app/api";
import {
  Credentials,
  Suggestion,
  DataCountPayload,
  ChunkScore,
  Message,
  LabelsResponse,
  RAGConfig,
  Theme,
  DocumentFilter,
  MemoPayload, // Import MemoPayload type
  MemoResponse, // Import MemoResponse type
} from "@/app/types";

import InfoComponent from "../Navigation/InfoComponent";
import MEMOConfig from "./MEMOConfig"; // Assuming MEMOConfig exists
import MEMOMessage from "./MEMOMessage"; // Assuming MEMOMessage exists

interface MEMOInterfaceProps {
  credentials: Credentials;
  setSelectedDocument: (s: string | null) => void;
  setSelectedChunkScore: (c: ChunkScore[]) => void;
  currentPage: string;
  RAGConfig: RAGConfig | null;
  setRAGConfig: React.Dispatch<React.SetStateAction<RAGConfig | null>>;
  selectedTheme: Theme;
  addStatusMessage: (
    message: string,
    type: "INFO" | "WARNING" | "SUCCESS" | "ERROR"
  ) => void;
  production: "Local" | "Demo" | "Production";
  documentFilter: DocumentFilter[];
  setDocumentFilter: React.Dispatch<React.SetStateAction<DocumentFilter[]>>;
  selectedDocument: string | null; // Receive selectedDocument from MEMOView
}

const MEMOInterface: React.FC<MEMOInterfaceProps> = ({
  credentials,
  setSelectedDocument,
  setSelectedChunkScore,
  currentPage,
  RAGConfig,
  setRAGConfig,
  selectedTheme,
  addStatusMessage,
  production,
  documentFilter,
  setDocumentFilter,
  selectedDocument, // Use selectedDocument prop
}) => {
  const [messages, setMessages] = useState<Message[]>([
    { type: "system", content: selectedTheme.intro_message.text },
  ]);
  const [userInput, setUserInput] = useState<string>("");
  const [isStreaming, setIsStreaming] = useState<boolean>(false);
  const [dataCount, setDataCount] = useState<DataCountPayload>({
    total: 0,
    documents: 0,
    chunks: 0,
  });
  const [connected, setConnected] = useState<boolean>(true);
  const [currentSuggestions, setCurrentSuggestions] = useState<Suggestion[]>(
    []
  );
  const [selectedDocumentScore, setSelectedDocumentScore] = useState<
    string | null
  >(null);
  const [showConfig, setShowConfig] = useState<boolean>(false);
  const [labels, setLabels] = useState<LabelsResponse | null>(null);

  // New state for memo generation
  const [memoTemplate, setMemoTemplate] = useState<string>("");
  const [memoResult, setMemoResult] = useState<string>("");
  const [isGeneratingMemo, setIsGeneratingMemo] = useState<boolean>(false);

  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  const sendMemo = async () => {
    if ((!selectedDocument && !userInput) || !memoTemplate) {
      addStatusMessage(
        "Please select a document or enter text, and provide a memo template.",
        "WARNING"
      );
      return;
    }

    setIsGeneratingMemo(true);
    addStatusMessage("Generating memo...", "INFO");

    const payload: MemoPayload = {
      memo_template: memoTemplate,
      credentials: credentials,
      rag_config: RAGConfig || undefined, // Optional RAGConfig
    };

    if (selectedDocument) {
      payload.document_uuid = selectedDocument;
    } else if (userInput) {
      payload.text_content = userInput;
    }

    try {
      const response: MemoResponse = await sendMemoRequest(payload);
      if (response && response.memo_text) {
        setMemoResult(response.memo_text);
        addStatusMessage("Memo generated successfully!", "SUCCESS");
      } else {
        setMemoResult("Error: Failed to generate memo.");
        addStatusMessage("Failed to generate memo.", "ERROR");
      }
    } catch (error) {
      console.error("Error generating memo:", error);
      setMemoResult(`Error: ${error instanceof Error ? error.message : String(error)}`);
      addStatusMessage(
        `Error generating memo: ${error instanceof Error ? error.message : String(error)}`,
        "ERROR"
      );
    } finally {
      setIsGeneratingMemo(false);
    }
  };

  const reconnectToVerba = async () => {
    // Reconnection logic (similar to ChatInterface)
    setConnected(false);
    addStatusMessage("Attempting to reconnect...", "INFO");
    try {
      const config = await fetchRAGConfig(credentials);
      if (config) {
        setRAGConfig(config.rag_config);
        addStatusMessage("Reconnected successfully!", "SUCCESS");
        setConnected(true);
      } else {
        addStatusMessage("Failed to reconnect to Verba. Please check server.", "ERROR");
      }
    } catch (error) {
      addStatusMessage("Failed to reconnect to Verba. Please check server.", "ERROR");
      console.error("Reconnection error:", error);
    }
  };

  const handleDocumentSelect = (event: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedDocument(event.target.value === "" ? null : event.target.value);
  };

  const handleReset = () => {
    setSelectedDocument(null);
    setSelectedChunkScore([]);
    setUserInput("");
    setMemoTemplate("");
    setMemoResult("");
    setSelectedDocumentScore(null);
    setCurrentSuggestions([]);
    setMessages([{ type: "system", content: selectedTheme.intro_message.text }]);
  };


  return (
    <div className="flex flex-col h-full w-full justify-between items-center bg-bg-alt-verba rounded-lg">
      <div className="flex flex-row justify-between items-center w-full p-4">
        <div className="flex items-center gap-2">
          <img
            src={selectedTheme.image.src}
            alt="Theme Logo"
            className="w-8 h-8 rounded-full"
          />
          <h3 className="text-xl font-bold text-text-verba">
            {selectedTheme.title.text} - MEMO
          </h3>
        </div>
        <VerbaButton
          Icon={MdOutlineRefresh}
          onClick={handleReset}
          disabled={false}
          selected_color="bg-primary-verba"
          title="Reset MEMO"
        />
      </div>

      <div className="flex-grow w-full overflow-y-auto p-4 flex flex-col justify-start gap-4">
        <div className="flex flex-col gap-2">
          <label className="text-text-verba text-sm">
            Select Document for Memo (Optional):
          </label>
          <select
            className="select select-bordered w-full bg-bg-verba text-text-verba border-border-verba"
            value={selectedDocument || ""}
            onChange={handleDocumentSelect}
          >
            <option value="">No Document Selected (Enter text below)</option>
            {documentFilter.map((doc) => (
              <option key={doc.uuid} value={doc.uuid}>
                {doc.title}
              </option>
            ))}
          </select>
        </div>

        {!selectedDocument && (
          <div className="flex flex-col gap-2">
            <label className="text-text-verba text-sm">
              Enter Text Content for Memo (If no document selected):
            </label>
            <textarea
              className="textarea textarea-bordered w-full bg-bg-verba text-text-verba border-border-verba"
              placeholder="Enter text here..."
              value={userInput}
              onChange={(e) => setUserInput(e.target.value)}
              rows={6}
            ></textarea>
          </div>
        )}

        <div className="flex flex-col gap-2">
          <label className="text-text-verba text-sm">Memo Template:</label>
          <textarea
            className="textarea textarea-bordered w-full bg-bg-verba text-text-verba border-border-verba"
            placeholder="Enter your memo template. Use {context} to inject document content. Example: 'Write a summary of {context} in 100 words.'"
            value={memoTemplate}
            onChange={(e) => setMemoTemplate(e.target.value)}
            rows={6}
          ></textarea>
        </div>

        <VerbaButton
          type="button"
          Icon={IoIosSend}
          onClick={sendMemo}
          disabled={isGeneratingMemo || (!selectedDocument && !userInput) || !memoTemplate}
          selected_color="bg-primary-verba"
          title="Generate Memo"
          className="w-full"
        >
          {isGeneratingMemo ? "Generating..." : "Generate Memo"}
        </VerbaButton>

        {memoResult && (
          <div className="flex flex-col gap-2">
            <h3 className="text-lg font-bold text-text-verba">Generated Memo:</h3>
            <div className="p-4 rounded-lg bg-bg-verba text-text-verba whitespace-pre-wrap">
              {memoResult}
            </div>
          </div>
        )}
      </div>

      <div className="flex flex-col p-4 w-full">
        {connected ? (
          <div className="flex gap-2 items-center justify-end w-full">
            <div className="flex gap-2">
              {/* This section can be repurposed if needed, or removed if no user input chat is desired */}
            </div>
          </div>
        ) : (
          <div className="flex gap-2 items-center justify-end w-full">
            <button
              onClick={reconnectToVerba}
              className="flex btn border-none text-text-verba bg-button-verba hover:bg-button-hover-verba gap-2 items-center"
            >
              <TbPlugConnected size={15} />
              <p>Reconnecting...</p>
              <span className="loading loading-spinner loading-xs"></span>
            </button>
          </div>
        )}
      </div>
    </div>
  );
};

export default MEMOInterface;
3. MEMOMessage.tsx
Since the MEMOInterface is now focused on generating a single memo output rather than a conversational chat, the MEMOMessage component's role changes significantly. If the MEMOInterface is only displaying the final generated memo, this component might become redundant or need to be heavily simplified.

Given the current MEMOInterface displays the memoResult directly, MEMOMessage is likely no longer needed for displaying individual "messages" in a chat-like format. You can either remove MEMOMessage.tsx or keep it if you anticipate a future need for displaying a history of generated memos (which would require more complex state management in MEMOInterface).

For now, let's assume it's not strictly necessary and focus on the other components. If you still want to display some kind of "message" (e.g., a "system" message about the memo being generated), you can adapt it, but its current structure for message.content and document.title (from a RAG chat) won't directly apply.

Recommendation: If MEMOMessage.tsx is only used to display chat messages, you can remove it or keep it as is, understanding it won't be actively used by the new MEMOInterface for displaying memo results.

If you do want to adapt MEMOMessage to display the generated memo, it would look something like this, but you'd need to adjust how memoResult from MEMOInterface is passed down:

TypeScript

// MEMOMessage.tsx (Optional, if you want to display the memo result using a message component)
"use client";

import React from "react";
import { ChunkScore, Message } from "@/app/types"; // Message type might need adjustment for memo output
import ReactMarkdown from "react-markdown";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/cjs/styles/prism";

import { Theme } from "@/app/types";

interface MEMOMessageProps {
  message: Message; // This 'Message' type would need to be very generic or re-defined for memo content
  selectedTheme: Theme;
  // Other props related to document/chunk selection might not be needed for a simple memo display
}

const MEMOMessage: React.FC<MEMOMessageProps> = ({
  message,
  selectedTheme,
}) => {
  const isSystem = message.type === "system";
  const isError = message.type === "error";

  const colorTable = {
    user: "bg-bg-verba",
    system: "bg-bg-alt-verba",
    error: "bg-warning-verba",
    retrieval: "bg-bg-verba",
  };

  const messageBgClass =
    colorTable[message.type as keyof typeof colorTable] || "bg-bg-verba";

  return (
    <div
      className={`chat ${isSystem ? "chat-start" : "chat-end"} w-full fade-in-left `}
    >
      <div className={`chat-bubble w-full ${messageBgClass}`}>
        <ReactMarkdown
          components={{
            code({ node, inline, className, children, ...props }) {
              const match = /language-(\w+)/.exec(className || "");
              return !inline && match ? (
                <SyntaxHighlighter
                  style={selectedTheme.theme === "dark" ? oneDark : oneLight}
                  language={match[1]}
                  PreTag="div"
                  {...props}
                >
                  {String(children).replace(/\n$/, "")}
                </SyntaxHighlighter>
              ) : (
                <code className={className} {...props}>
                  {children}
                </code>
              );
            },
          }}
        >
          {message.content}
        </ReactMarkdown>
      </div>
    </div>
  );
};

export default MEMOMessage;
4. MEMOConfig.tsx
This component currently seems to be a direct copy of ChatConfig.tsx, dealing with RAG component selection (Embedder, Generator, Retriever). If the MEMO generation process relies on the same RAG configuration, then the MEMOConfig.tsx can remain largely the same. It provides settings for the underlying LLM and retrieval mechanisms that sendMemoRequest would utilize.

TypeScript

"use client";

import React, { useCallback } from "react";
import { MdCancel } from "react-icons/md";
import { IoSettingsSharp } from "react-icons/io5";
import { RAGConfig, RAGComponentConfig, Credentials } from "@/app/types";
import { updateRAGConfig } from "@/app/api";
import ComponentView from "../Ingestion/ComponentView"; // Re-using ComponentView

import VerbaButton from "../Navigation/VerbaButton";

interface ChatConfigProps {
  RAGConfig: RAGConfig | null;
  setRAGConfig: React.Dispatch<React.SetStateAction<RAGConfig | null>>;
  onSave: () => void; // New parameter for handling save
  onReset: () => void; // New parameter for handling reset
  addStatusMessage: (
    message: string,
    type: "INFO" | "WARNING" | "SUCCESS" | "ERROR"
  ) => void;
  credentials: Credentials;
  production: "Local" | "Demo" | "Production";
}

const MEMOConfig: React.FC<ChatConfigProps> = ({ // Renamed to MEMOConfig
  RAGConfig,
  setRAGConfig,
  addStatusMessage,
  onSave,
  credentials,
  onReset,
  production,
}) => {
  const updateConfig = useCallback(
    (component_n: string, configTitle: string, value: string | boolean | string[]) => {
      setRAGConfig((prevRAGConfig) => {
        if (prevRAGConfig) {
          const newRAGConfig = { ...prevRAGConfig };
          if (typeof value === "string" || typeof value === "boolean") {
            const component = newRAGConfig[component_n as keyof RAGConfig] as RAGComponentConfig;
            if (component && component.config) {
              const configItem = component.config.find(
                (item) => item.title === configTitle
              );
              if (configItem) {
                configItem.value = value;
              }
            }
          } else if (Array.isArray(value)) {
            // Handle array type for multiselect
            const component = newRAGConfig[component_n as keyof RAGConfig] as RAGComponentConfig;
            if (component && component.config) {
              const configItem = component.config.find(
                (item) => item.title === configTitle
              );
              if (configItem) {
                configItem.value = value.join(","); // Assuming value needs to be comma-separated string
              }
            }
          }
          return newRAGConfig;
        }
        return prevRAGConfig;
      });
    },
    [setRAGConfig]
  );

  const saveComponentConfig = async (component_name: string) => {
    if (!RAGConfig) {
      addStatusMessage("RAGConfig is not loaded.", "WARNING");
      return;
    }

    addStatusMessage(`Saving ${component_name} config...`, "INFO");
    try {
      const response = await updateRAGConfig(
        RAGConfig,
        credentials,
        component_name
      );
      if (response && response.rag_config) {
        setRAGConfig(response.rag_config);
        addStatusMessage(`${component_name} config saved!`, "SUCCESS");
      } else {
        addStatusMessage(`Failed to save ${component_name} config.`, "ERROR");
      }
    } catch (error) {
      addStatusMessage(`Error saving ${component_name} config.`, "ERROR");
      console.error(`Error saving ${component_name} config:`, error);
    }
  };

  if (RAGConfig) {
    return (
      <div className="flex flex-col gap-3 rounded-2xl p-4 bg-bg-alt-verba h-full overflow-y-auto">
        <div className="flex justify-end gap-2 p-4 bg-bg-alt-verba rounded-lg">
          <VerbaButton
            Icon={IoSettingsSharp}
            title="Save Config"
            onClick={onSave}
            disabled={production == "Demo"}
          />
          <VerbaButton
            Icon={MdCancel}
            title="Reset"
            onClick={onReset}
            disabled={production == "Demo"}
          />
        </div>

        <div className="flex flex-col justify-start gap-3 rounded-2xl w-full p-6 ">
          <ComponentView
            RAGConfig={RAGConfig}
            component_name="Embedder"
            selectComponent={updateConfig}
            updateConfig={updateConfig}
            saveComponentConfig={saveComponentConfig}
            blocked={production == "Demo"}
          />
          <ComponentView
            RAGConfig={RAGConfig}
            component_name="Generator"
            selectComponent={updateConfig}
            updateConfig={updateConfig}
            saveComponentConfig={saveComponentConfig}
            blocked={production == "Demo"}
          />
          <ComponentView
            RAGConfig={RAGConfig}
            component_name="Retriever"
            selectComponent={updateConfig}
            updateConfig={updateConfig}
            saveComponentConfig={saveComponentConfig}
            blocked={production == "Demo"}
          />
        </div>
      </div>
    );
  } else {
    return <div></div>;
  }
};

export default MEMOConfig;
5. types.ts (For new Memo Payload)
You need to define the new types for MemoPayload and MemoResponse in your types.ts file. This is crucial for the API communication.

TypeScript

// Add these types to your existing types.ts file

export type MemoPayload = {
  memo_template: string;
  document_uuid?: string | null; // Optional, if generating memo from an existing document
  text_content?: string | null; // Optional, if generating memo from direct text input
  credentials: Credentials;
  rag_config?: RAGConfig | null; // Optional, to pass RAG config
};

export type MemoResponse = {
  memo_text: string;
};
6. api.ts (For new Memo API call)
You'll need a new function in your api.ts file to send the memo generation request to your backend.

TypeScript

// Add this function to your existing api.ts file

import { MemoPayload, MemoResponse } from "./types";

export const sendMemoRequest = async (
  payload: MemoPayload
): Promise<MemoResponse | null> => {
  try {
    const host = await detectHost();
    const response = await fetch(`${host}/api/generate_memo`, { // Assuming your FastAPI endpoint is /api/generate_memo
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error(`Error ${response.status}: ${response.statusText}`);
      const errorData = await response.json();
      console.error("Error details:", errorData);
      return { memo_text: `Error: ${errorData.memo_text || "Failed to generate memo."}` }; // Return error message in memo_text
    }

    const data: MemoResponse = await response.json();
    return data;
  } catch (error) {
    console.error("Error sending memo request", error);
    let errorMessage = "Network or unexpected error.";

    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === 'string') {
      errorMessage = error;
    } else if (error && typeof error === 'object' && 'message' in error) {
      errorMessage = (error as { message: string }).message;
    }

    return { memo_text: `Error: ${errorMessage}` }; // Return error message in memo_text
  }
};
7. api.py (FastAPI Backend - New Endpoint)
On your FastAPI backend, you'll need to add a new endpoint to handle the memo generation request. This endpoint will receive the MemoPayload, retrieve document content if a document_uuid is provided, or use the text_content directly, and then call your verba_manager to generate the memo.

Python

# Add this to your api.py

from goldenverba.server.types import MemoPayload, MemoResponse # Make sure MemoPayload is imported

# ... (other imports and app setup) ...

@app.post("/api/generate_memo")
async def generate_memo(payload: MemoPayload):
    try:
        client = await client_manager.connect(payload.credentials)

        document_content = ""
        if payload.document_uuid:
            # Assuming you have a method to retrieve document content by UUID
            # This method should return the full text content of the document
            document_data = await manager.weaviate_manager.retrieve_document_content(client, payload.document_uuid)
            document_content = document_data.get("content", "") # Adjust 'content' key based on your data structure
            if not document_content:
                msg.warning(f"No content found for document UUID: {payload.document_uuid}")
                return JSONResponse(
                    content={"memo_text": "Error: Document content not found for the selected document."},
                    status_code=404
                )
        elif payload.text_content:
            document_content = payload.text_content
        else:
            return JSONResponse(
                content={"memo_text": "Error: Document UUID or text content is required."},
                status_code=400
            )

        # Call the manager to create the memo
        # This function needs to be implemented in your VerbaManager or a sub-manager (e.g., WeaviateManager)
        memo_result = await manager.weaviate_manager.create_memo_with_template(
            client,
            payload.memo_template, # Template from the user
            document_content,      # Document context
            payload.rag_config     # RAG configuration
        )
        return JSONResponse(
            content={
                "memo_text": memo_result,
            }
        )
    except Exception as e:
        msg.fail(f"Error during memo generation: {e}")
        return JSONResponse(
            content={
                "memo_text": f"Error: Could not generate memo. Details: {str(e)}",
            },
            status_code=500
        )
8. managers.py (FastAPI Backend - New Method)
You'll need to implement the retrieve_document_content and create_memo_with_template methods in your WeaviateManager (or verba_manager if that's where you centralize such logic).

Python

# Add these methods to your WeaviateManager in managers.py

class WeaviateManager:
    # ... (existing methods) ...

    async def retrieve_document_content(self, client: WeaviateAsyncClient, document_uuid: str) -> dict:
        """
        Retrieves the full content of a document by its UUID.
        """
        try:
            # Assuming your 'Document' collection has a 'doc_uuid' and 'text' property
            response = await client.collections.get("Document").query.fetch_object_by_id(
                uuid=document_uuid,
                return_properties=["text"] # Fetch the property that contains the document's content
            )
            if response and response.properties:
                return {"content": response.properties.get("text", "")}
            return {"content": ""}
        except Exception as e:
            msg.fail(f"Error retrieving document content for UUID {document_uuid}: {e}")
            return {"content": ""}

    async def create_memo_with_template(self, client: WeaviateAsyncClient, memo_template: str, document_content: str, rag_config: dict) -> str:
        """
        Generates a memo using the provided template and document content.
        This method will leverage your chosen Generator (LLM).
        """
        try:
            # This part needs to dynamically select the generator based on rag_config
            # For simplicity, let's assume a default generator or retrieve it from rag_config
            generator_name = rag_config.get("Generator", {}).get("selected_component")
            if not generator_name:
                raise ValueError("Generator not specified in RAGConfig.")

            # Load the actual generator instance (e.g., OpenAI, Ollama etc.)
            # This logic might be within your VerbaManager already or needs to be added
            generator_instance: Generator = self._get_generator_instance(generator_name) # You'll need to implement _get_generator_instance

            # Replace placeholder in template with actual content
            # This is a very basic replacement. For more complex templating, consider jinja2 or similar.
            prompt = memo_template.replace("{context}", document_content)

            # Prepare messages for the generator (similar to chat message preparation)
            # You might need to adjust this based on the specific LLM's message format
            messages = generator_instance.prepare_messages(
                queries=[prompt],
                context=[], # Context is already injected into the prompt
                conversation={} # No prior conversation for a single memo generation
            )

            # Generate the memo
            # Assuming generate_stream returns an async generator or a direct response
            memo_tokens = ""
            async for token_response in generator_instance.generate_stream(messages, rag_config=rag_config):
                if token_response and token_response.get("system"):
                    memo_tokens += token_response["system"]

            return memo_tokens.strip()
        except Exception as e:
            msg.fail(f"Error creating memo with template: {e}")
            raise # Re-raise to be caught by the FastAPI endpoint

    def _get_generator_instance(self, generator_name: str) -> Generator:
        """
        Helper to retrieve the configured generator instance.
        This should map the generator name (e.g., "OpenAI") to its class instance.
        You should have a registry of your components in `verba_manager`.
        """
        # Example (adapt to your actual component loading logic)
        from goldenverba.components.generator.OpenAI import OpenAI
        from goldenverba.components.generator.Ollama import OllamaGenerator # Example if you have Ollama

        if generator_name == "OpenAI":
            return OpenAI()
        elif generator_name == "Ollama":
            return OllamaGenerator()
        # Add other generators as needed
        else:
            raise ValueError(f"Unknown generator: {generator_name}")

Summary of Changes:
MEMOView.tsx:

Manages selectedDocument and selectedChunkScore states.

Passes these states down to MEMOInterface and DocumentExplorer.

MEMOInterface.tsx:

Introduces state for memoTemplate, memoResult, and isGeneratingMemo.

Adds a dropdown for selecting an existing document based on documentFilter.

Adds a textarea for direct text input if no document is selected.

Adds a textarea for the memo template.

Modifies the "send" button to trigger sendMemo.

Calls the new sendMemoRequest API function.

Displays the memoResult.

Cleans up messages state as it's no longer a chat.

Adds a reset button for memo specific fields.

MEMOMessage.tsx:

Likely redundant for a simple memo generation display. Can be removed or repurposed if memo history is desired.

MEMOConfig.tsx:

Remains largely the same, assuming RAG configuration (Embedder, Generator, Retriever) is still relevant for memo generation.

types.ts:

Adds MemoPayload and MemoResponse types for API communication.

api.ts:

Adds sendMemoRequest function to handle the API call to your FastAPI backend.

api.py (Backend):

Adds a new FastAPI endpoint /api/generate_memo to receive the memo request.

Retrieves document content by UUID or uses direct text input.

Calls verba_manager (or weaviate_manager) to perform the memo generation using the RAG configuration.

managers.py (Backend):

Adds retrieve_document_content to fetch document text.

Adds create_memo_with_template to orchestrate the memo generation using the selected Generator and the provided template and context.

Includes a placeholder for _get_generator_instance to load the correct LLM.

These changes should transform your copied chat components into a functional memo generation interface that can leverage existing documents or new text input. Remember to thoroughly test each part of the new functionality.
