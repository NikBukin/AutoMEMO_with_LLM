Что это означает для вашего кода:

1. Изменение api.py (бэкенд):

В api.py, в эндпоинте /api/generate_memo (или соответствующей функции), удалите rag_config из параметров, передаваемых в create_memo_with_template.

Текущий код:

Python

@app.post("/api/generate_memo")
async def generate_memo(payload: MemoPayload):
    try:
        # ... получение client и document_content ...

        memo_result = await manager.weaviate_manager.create_memo_with_template(
            client,
            payload.memo_template, # Шаблон от пользователя
            document_content,      # Контекст документа
            payload.rag_config     # <-- Эту строку нужно удалить
        )
        # ...
Предлагаемое изменение:

Python

# goldenverba/server/api.py

@app.post("/api/generate_memo")
async def generate_memo(payload: MemoPayload):
    try:
        client = await client_manager.connect(payload.credentials)
        document_content = ""
        if payload.document_uuid:
            document_data = await manager.weaviate_manager.retrieve_document_content(client, payload.document_uuid)
            document_content = document_data.get("content", "")
        elif payload.text_content:
            document_content = payload.text_content
        else:
            return JSONResponse(
                content={"memo_text": "Error: Document context or UUID is required."},
                status_code=400
            )

        memo_result = await manager.weaviate_manager.create_memo_with_template(
            client,
            payload.memo_template,
            document_content
            # Здесь больше НЕ передается payload.rag_config
        )
        return JSONResponse(
            content={
                "memo_text": memo_result,
            }
        )
    except Exception as e:
        msg.fail(f"Error during memo generation: {e}")
        return JSONResponse(
            content={
                "memo_text": f"Error: Could not generate memo. Details: {str(e)}",
            },
            status_code=500
        )
2. Изменение types.py (бэкенд):

Удалите rag_config: Optional[RAGConfig] = None из класса MemoPayload, так как он больше не будет частью полезной нагрузки запроса.

Текущий код:

Python

# goldenverba/server/types.py

class MemoPayload(BaseModel):
    memo_template: str
    document_uuid: Optional[str] = None
    text_content: Optional[str] = None
    credentials: Credentials
    rag_config: Optional[RAGConfig] = None # <-- Эту строку нужно удалить
Предлагаемое изменение:

Python

# goldenverba/server/types.py

class MemoPayload(BaseModel):
    memo_template: str
    document_uuid: Optional[str] = None
    text_content: Optional[str] = None
    credentials: Credentials
    # rag_config больше не нужен
3. Изменение weaviate_manager.py (бэкенд):

Обновите сигнатуру функции create_memo_with_template, чтобы она не принимала rag_config.

Текущий код (предполагаемый):

Python

# goldenverba/retrievers/weaviate_manager.py (или где-то еще, где определен create_memo_with_template)

class WeaviateManager:
    # ... другие методы ...
    async def create_memo_with_template(
        self,
        client: WeaviateAsyncClient,
        memo_template: str,
        document_content: str,
        rag_config: dict[str, RAGComponentClass] # <-- Этот параметр нужно удалить
    ) -> str:
        # ... ваша логика ...
Предлагаемое изменение:

Python

# goldenverba/retrievers/weaviate_manager.py

class WeaviateManager:
    # ... другие методы ...
    async def create_memo_with_template(
        self,
        client: WeaviateAsyncClient,
        memo_template: str,
        document_content: str
        # rag_config больше не нужен
    ) -> str:
        # Теперь LLM будет использоваться только с template и content
        # Пример:
        generator_name = "ChatGPTGenerator" # Или ваш дефолтный генератор
        generator = get_generator(generator_name) # Получить экземпляр генератора
        
        # Подготовить промпт для LLM, используя шаблон и контент
        # Это может быть более сложная логика в зависимости от шаблона
        query = memo_template
        context = document_content

        messages = generator.prepare_messages(
            queries=[query],
            context=[context],
            conversation=[] # Для МЕМО обычно не нужна история беседы
        )

        response_chunks = await generator.generate_stream(
            client=client,
            messages=messages,
            # Здесь могут быть параметры, специфичные для генератора, но без rag_config
        )
        
        full_response = ""
        for chunk in response_chunks:
            full_response += chunk.get("system", "")
        return full_response
Важный момент: В функции create_memo_with_template вам нужно будет решить, какой генератор использовать (например, "ChatGPTGenerator" или какой-то другой по умолчанию), так как rag_config больше не будет предоставлять эту информацию. Вы можете либо жестко закодировать имя генератора, либо получать его из какой-то глобальной или дефолтной конфигурации.

4. Изменение api.ts (фронтенд):

В api.ts, в функции sendMemoRequest, удалите rag_config из объекта payload, который отправляется на бэкенд.

Текущий код:

TypeScript

// app/api.ts

export const sendMemoRequest = async (
  payload: MemoPayload
): Promise<MemoResponse> => {
  try {
    const host = await detectHost();
    const response = await fetch(`${host}/api/generate_memo`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload), // payload содержит rag_config
    });
    // ...
Предлагаемое изменение:

TypeScript

// app/api.ts

// ... (импорты и другие функции) ...

export const sendMemoRequest = async (
  payload: MemoPayload // MemoPayload теперь не должен содержать rag_config
): Promise<MemoResponse> => {
  try {
    const host = await detectHost();
    const response = await fetch(`${host}/api/generate_memo`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        memo_template: payload.memo_template,
        document_uuid: payload.document_uuid,
        text_content: payload.text_content,
        credentials: payload.credentials,
        // rag_config здесь больше НЕ передается
      }),
    });

    if (!response.ok) {
      console.error(`Error ${response.status}: ${response.statusText}`);
      const errorData = await response.json();
      console.error("Error details:", errorData);
      return { memo_text: `Error: ${errorData.memo_text || "Failed to generate memo."}` };
    }

    const data: MemoResponse = await response.json();
    return data;
  } catch (error) {
    console.error("Error sending memo request", error);
    let errorMessage = "Network or unexpected error.";

    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === 'string') {
      errorMessage = error;
    } else if (error && typeof error === 'object' && 'message' in error) {
      errorMessage = (error as { message: string }).message;
    }

    return { memo_text: `Error: ${errorMessage}` };
  }
};
5. Изменение types.ts (фронтенд):

Удалите rag_config?: RAGConfig; из интерфейса MemoPayload.

Текущий код:

TypeScript

// app/types.ts

export type MemoPayload = {
  memo_template: string;
  document_uuid?: string;
  text_content?: string;
  credentials: Credentials;
  rag_config?: RAGConfig; // <-- Эту строку нужно удалить
};
Предлагаемое изменение:

TypeScript

// app/types.ts

export type MemoPayload = {
  memo_template: string;
  document_uuid?: string;
  text_content?: string;
  credentials: Credentials;
  // rag_config больше не нужен
};
Резюме:

Удаление rag_config из процесса создания МЕМО упростит систему, сделает ее более логичной для данного конкретного случая использования и устранит потенциальные проблемы с типами, связанные с передачей избыточной конфигурации. Это также означает, что MEMOConfig.tsx больше не будет отвечать за настройку RAG для генерации МЕМО, что соответствует вашему предложению.


А что делать с файлами MEMOView, MEMOConfig и остальными?



Вы затронули очень важный момент! Если мы убираем rag_config из логики создания МЕМО, то компоненты, связанные с MEMOConfig и MEMOView, также должны быть соответствующим образом адаптированы, чтобы избежать передачи ненужных пропсов или попыток использовать несуществующие конфигурации.

Давайте пройдемся по каждому из затронутых файлов и определим необходимые изменения.

1. MEMOConfig.tsx

Назначение: Этот компонент, судя по его содержимому, является интерфейсом для настройки RAG (Embedder, Generator, Retriever). Если МЕМО больше не использует RAG, то этот компонент больше не нужен для функционала МЕМО.

Действие:

MEMOConfig.tsx можно удалить, если его единственное назначение было конфигурировать RAG для МЕМО.

Если MEMOConfig используется где-то еще (например, в общем разделе настроек для RAG, не связанном с МЕМО), то его можно переименовать (например, в RAGConfigEditor.tsx) и переместить в более подходящее место, а из MEMOInterface.tsx удалить его импорт и использование.

2. MEMOInterface.tsx

Назначение: Это основной интерфейс для взаимодействия с функцией генерации МЕМО. Он принимает RAGConfig и setRAGConfig как пропсы.

Действие:

Удалить импорт MEMOConfig:

TypeScript

// Удалить эту строку, если MEMOConfig удаляется или переименовывается
// import MEMOConfig from "./MEMOConfig";
Удалить MEMOConfig из рендера:
В JSX-коде удалите <MEMOConfig ... /> и любые связанные элементы UI, которые использовались для его отображения (например, вкладку "Config" или кнопку для его открытия).

Удалить RAGConfig и setRAGConfig из MEMOInterfaceProps:

TypeScript

interface MEMOInterfaceProps {
  credentials: Credentials;
  setSelectedDocument: (s: string | null) => void;
  setSelectedChunkScore: (c: ChunkScore[]) => void;
  addStatusMessage: (
    message: string,
    type: "INFO" | "WARNING" | "SUCCESS" | "ERROR"
  ) => void;
  production: "Local" | "Demo" | "Production";
  selectedTheme: Theme;
  // Эти строки больше не нужны:
  // RAGConfig: RAGConfig | null;
  // setRAGConfig: React.Dispatch<React.SetStateAction<RAGConfig | null>>;
  documentFilter: DocumentFilter[];
  setDocumentFilter: React.Dispatch<React.SetStateAction<DocumentFilter[]>>;
  currentPage: string;
}
Удалить RAGConfig и setRAGConfig из деструктуризации пропсов:

TypeScript

const MEMOInterface: React.FC<MEMOInterfaceProps> = ({
  credentials,
  setSelectedDocument,
  setSelectedChunkScore,
  addStatusMessage,
  production,
  selectedTheme,
  // RAGConfig, // <-- Удалить
  // setRAGConfig, // <-- Удалить
  documentFilter,
  setDocumentFilter,
  currentPage,
}) => {
Обновить вызов sendMemoRequest:
Если вы используете sendMemoRequest для отправки запроса на генерацию МЕМО, убедитесь, что payload.rag_config не передается. Вы уже начали это делать в предыдущем ответе.

TypeScript

// В функции sendUserMessage или аналогичной
// Вместо:
// const payload: MemoPayload = {
//   memo_template: userInput,
//   document_uuid: selectedDocument || undefined,
//   credentials: credentials,
//   rag_config: RAGConfig || undefined, // <-- Здесь RAGConfig больше не нужен
// };

// Должно быть:
const payload: MemoPayload = {
  memo_template: userInput,
  document_uuid: selectedDocument || undefined,
  credentials: credentials,
  // rag_config полностью удален
};

const response = await sendMemoRequest(payload);
3. MEMOView.tsx

Назначение: Этот компонент является контейнером для MEMOInterface и DocumentExplorer. Он передает RAGConfig и setRAGConfig дальше в MEMOInterface.

Действие:

Удалить RAGConfig и setRAGConfig из MEMOViewProps:

TypeScript

interface MEMOViewProps {
  selectedTheme: Theme;
  credentials: Credentials;
  addStatusMessage: (
    message: string,
    type: "INFO" | "WARNING" | "SUCCESS" | "ERROR"
  ) => void;
  production: "Local" | "Demo" | "Production";
  currentPage: string;
  // Эти строки больше не нужны:
  // RAGConfig: RAGConfig | null;
  // setRAGConfig: React.Dispatch<React.SetStateAction<RAGConfig | null>>;
  documentFilter: DocumentFilter[];
  setDocumentFilter: React.Dispatch<React.SetStateAction<DocumentFilter[]>>;
}
Удалить RAGConfig и setRAGConfig из деструктуризации пропсов:

TypeScript

const MEMOView: React.FC<MEMOViewProps> = ({
  credentials,
  selectedTheme,
  addStatusMessage,
  production,
  currentPage,
  // RAGConfig, // <-- Удалить
  // setRAGConfig, // <-- Удалить
  documentFilter,
  setDocumentFilter,
}) => {
Удалить передачу RAGConfig и setRAGConfig в MEMOInterface:

TypeScript

<MEMOInterface
  addStatusMessage={addStatusMessage}
  production={production}
  credentials={credentials}
  selectedTheme={selectedTheme}
  setSelectedDocument={setSelectedDocument}
  setSelectedChunkScore={setSelectedChunkScore}
  currentPage={currentPage}
  // RAGConfig={RAGConfig} // <-- Удалить
  // setRAGConfig={setRAGConfig} // <-- Удалить
  documentFilter={documentFilter}
  setDocumentFilter={setDocumentFilter}
/>
4. page.tsx (или page (1).tsx)

Назначение: Это основной компонент страницы, который управляет состоянием RAGConfig и передает его в различные View-компоненты.

Действие:

Проверить использование RAGConfig: В page.tsx есть строки:

TypeScript

<MEMOView
  // ... другие пропсы
  RAGConfig={RAGConfig}
  setRAGConfig={setRAGConfig}
  documentFilter={documentFilter}
  setDocumentFilter={setDocumentFilter}
/>
Эти пропсы RAGConfig и setRAGConfig должны быть удалены из передачи в MEMOView, так как MEMOView (и, соответственно, MEMOInterface) больше не будет их принимать.

TypeScript

<MEMOView
  selectedTheme={selectedTheme}
  credentials={credentials}
  addStatusMessage={addStatusMessage}
  production={production}
  currentPage={currentPage}
  // RAGConfig={RAGConfig} // <-- Удалить
  // setRAGConfig={setRAGConfig} // <-- Удалить
  documentFilter={documentFilter}
  setDocumentFilter={setDocumentFilter}
/>
Убедитесь, что RAGConfig и setRAGConfig по-прежнему используются для других компонентов, таких как ChatView и IngestionView, где RAG все еще актуален. Изменения должны касаться только функционала МЕМО.

5. MEMOMessage.tsx

Назначение: Этот компонент отвечает за отображение отдельных сообщений МЕМО. Он не имеет прямого отношения к конфигурации RAG, но отображает "контекст" (message.context), который ранее мог быть результатом RAG.

Действие: Вероятно, никаких изменений не требуется. MEMOMessage просто отображает то, что ему передается в пропсах. Если логика бэкенда теперь возвращает МЕМО, сгенерированное без RAG, то message.context будет пустым или содержать только исходный document_content, если вы решите его включить в ответ.

Итог:

Ваше предложение сильно упростит структуру, сделав ее более чистой и специализированной. Основные шаги:

Удалить или переназначить MEMOConfig.tsx.

Удалить ссылки на RAGConfig и setRAGConfig из MEMOInterface.tsx и MEMOView.tsx (из пропсов, деструктуризации и JSX-рендера).

Удалить передачу rag_config из MemoPayload при отправке запроса на бэкенд в api.ts (вы уже начали это делать).

Удалить rag_config из MemoPayload в types.ts и types.py.

Обновить сигнатуру create_memo_with_template в weaviate_manager.py, удалив rag_config как параметр, и убедиться, что генератор LLM вызывается только с memo_template и document_content.

Убедиться, что api.py не передает payload.rag_config в create_memo_with_template.

После этих изменений, функционал МЕМО будет полностью отделен от RAG-конфигурации, используя LLM исключительно для суммаризации предоставленного текста на основе шаблона.


