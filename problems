Отлично, вы хотите улучшить отображение размышлений Deepseek, чтобы они:

Появлялись в отдельном блоке в реальном времени по мере генерации, а не только по завершении.
Могли быть свернуты/развернуты.
Автоматически сворачивались после завершения генерации размышлений.
Это потребует более глубоких изменений, так как стриминг сообщений обрабатывается в ChatInterface.tsx, а отображение - в ChatMessage.tsx. Нам нужно будет скоординировать эти два компонента.

Анализ текущей реализации стриминга:
В ChatInterface.tsx:

WebSocket onmessage получает data.message и добавляет его к previewText.
Когда data.finish_reason === "stop", full_text из data.full_text добавляется в messages.
ChatMessage отображает previewText во время генерации.
Это означает, что весь стриминговый контент (включая <think> теги) собирается в previewText до тех пор, пока не будет получен finish_reason === "stop". Только после этого full_text (который и есть окончательный previewText) передается в messages.

Предлагаемые изменения:
Чтобы реализовать ваши требования, нам нужно:

Модифицировать ChatInterface.tsx для разделения потока: Когда мы получаем новые части сообщения, нам нужно проверять, находятся ли они внутри <think> тегов, и разделять их на thinkingContent и mainContent.
Обновить ChatMessage.tsx для обработки нового формата: ChatMessage.tsx должен будет принимать отдельные пропсы для размышлений и основного контента, а также состояние для сворачивания.
Добавить состояние для сворачивания: В ChatMessage.tsx нужно будет добавить состояние для отслеживания, свернут ли блок размышлений.
Добавить кнопку сворачивания/разворачивания: В ChatMessage.tsx нужно добавить кнопку, которая будет переключать это состояние.
Автоматическое сворачивание: После finish_reason === "stop", мы можем отправить флаг, чтобы ChatMessage автоматически свернул блок размышлений.
Это будет довольно сложная модификация, особенно управление состоянием стриминга.

Давайте начнем с изменений в ChatInterface.tsx, чтобы он мог разделять поступающий текст на "размышления" и "основной ответ" в реальном времени.

Шаг 1: Изменения в ChatInterface.tsx
Мы будем отслеживать два previewText состояния: currentThinkText и currentMainText.

TypeScript

// ChatInterface.tsx
// ... (существующие импорты и код)

const ChatInterface: React.FC<ChatInterfaceProps> = ({
  // ... (существующие пропсы)
}) => {
  // ... (существующие useState, useRef)

  // Изменяем previewText на два отдельных состояния
  const [currentThinkText, setCurrentThinkText] = useState(""); // Для размышлений
  const [currentMainText, setCurrentMainText] = useState("");   // Для основного ответа

  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [socketOnline, setSocketOnline] = useState(false);
  const [reconnect, setReconnect] = useState(false);

  // Добавляем состояние для отслеживания, находимся ли мы внутри тегов <think>
  const isThinking = useRef<boolean>(false);
  // Добавляем состояние для автоматического сворачивания после завершения
  const [collapseThinkBlock, setCollapseThinkBlock] = useState<boolean>(true);


  // ... (существующие useEffect'ы)

  // Setup WebSocket and messages to /ws/generate_stream
  useEffect(() => {
    const socketHost = getWebSocketApiHost();
    const localSocket = new WebSocket(socketHost);

    localSocket.onopen = () => {
      console.log("WebSocket connection opened to " + socketHost);
      setSocketOnline(true);
    };

    localSocket.onmessage = (event) => {
      let data;

      if (!isFetching.current) {
        // Сбрасываем все временные тексты, если fetch был отменен
        setCurrentThinkText("");
        setCurrentMainText("");
        return;
      }

      try {
        data = JSON.parse(event.data);
      } catch (e) {
        console.error("Received data is not valid JSON:", event.data);
        return; // Exit early if data isn't valid JSON
      }

      const newMessageContent = data.message;

      // === НАЧАЛО ИЗМЕНЕНИЙ В ОБРАБОТЧИКЕ onmessage ===

      let contentToProcess = newMessageContent;

      // Проверяем, начинается ли новый фрагмент с <think>
      if (contentToProcess.includes("<think>")) {
        isThinking.current = true;
        // Удаляем <think> из потока, чтобы не отображать его
        contentToProcess = contentToProcess.replace("<think>", "");
        setCollapseThinkBlock(false); // Разворачиваем блок, как только начинаются размышления
      }

      // Проверяем, заканчивается ли новый фрагмент на </think>
      if (contentToProcess.includes("</think>")) {
        isThinking.current = false;
        // Удаляем </think> из потока
        contentToProcess = contentToProcess.replace("</think>", "");
        // Мы не сворачиваем блок здесь, мы сворачиваем его при finish_reason === "stop"
      }

      if (isThinking.current) {
        setCurrentThinkText((prev) => prev + contentToProcess);
      } else {
        // Если isThinking.current ложно, но до этого было истинно,
        // это означает, что мы только что вышли из блока <think>.
        // Оставшийся contentToProcess относится к основному тексту.
        setCurrentMainText((prev) => prev + contentToProcess);
      }

      // === КОНЕЦ ИЗМЕНЕНИЙ В ОБРАБОТЧИКЕ onmessage ===


      if (data.finish_reason === "stop") {
        isFetching.current = false;
        setFetchingStatus("DONE");
        addStatusMessage("Finished generation", "SUCCESS");

        // Объединяем оба текста для окончательного сообщения
        const full_text_content = currentThinkText ? `<think>${currentThinkText}</think>${currentMainText}` : currentMainText;
        //const full_text = data.full_text; // Этот full_text может быть неполным, если мы его разделяем
        // Мы используем наши собранные currentThinkText и currentMainText
        const finalMessageContent = full_text_content;

        if (data.cached) {
          const distance = data.distance;
          setMessages((prev) => [
            ...prev,
            {
              type: "system",
              content: finalMessageContent, // Используем наш объединенный текст
              cached: true,
              distance: distance,
              // Добавляем флаг, что это последнее сообщение, чтобы ChatMessage мог свернуться
              autoCollapseThink: true, // НОВОЕ СВОЙСТВО
            },
          ]);
        } else {
          setMessages((prev) => [
            ...prev,
            {
              type: "system",
              content: finalMessageContent, // Используем наш объединенный текст
              autoCollapseThink: true, // НОВОЕ СВОЙСТВО
            },
          ]);
        }
        // Сбрасываем временные тексты после добавления окончательного сообщения
        setCurrentThinkText("");
        setCurrentMainText("");
        setPreviewText(""); // Общий previewText больше не используется напрямую для отображения
        setCollapseThinkBlock(true); // Сворачиваем блок размышлений после завершения
      }
    };

    localSocket.onerror = (error) => {
      console.error("WebSocket Error:", error);
      setSocketOnline(false);
      isFetching.current = false;
      setFetchingStatus("DONE");
      setReconnect((prev) => !prev);
      setCurrentThinkText(""); // Сбрасываем при ошибке
      setCurrentMainText("");  // Сбрасываем при ошибке
    };

    localSocket.onclose = (event) => {
      if (event.wasClean) {
        console.log(
          `WebSocket connection closed cleanly, code=${event.code}, reason=${event.reason}`
        );
      } else {
        console.error("WebSocket connection died");
      }
      setSocketOnline(false);
      isFetching.current = false;
      setFetchingStatus("DONE");
      setReconnect((prev) => !prev);
      setCurrentThinkText(""); // Сбрасываем при закрытии
      setCurrentMainText("");  // Сбрасываем при закрытии
    };

    setSocket(localSocket);

    return () => {
      if (localSocket.readyState !== WebSocket.CLOSED) {
        localSocket.close();
      }
    };
  }, [reconnect, currentThinkText, currentMainText]); // Добавляем зависимости для useEffect

  // ... (остальной код sendUserMessage, streamResponses, retrieveDatacount и т.д.)

  // В секции рендеринга, где отображается previewText
  return (
    // ...
          {currentThinkText || currentMainText ? ( // Изменено условие отображения previewText
            <ChatMessage
              message={{
                type: "system",
                content: currentMainText, // Основной текст
                thinkContent: currentThinkText, // Размышления
                cached: false,
                // Передаем состояние сворачивания, чтобы ChatMessage мог его отслеживать
                autoCollapseThink: collapseThinkBlock, // НОВОЕ СВОЙСТВО
              }}
              message_index={-1}
              selectedTheme={selectedTheme}
              selectedDocument={selectedDocumentScore}
              setSelectedDocumentScore={setSelectedDocumentScore}
              setSelectedDocument={setSelectedDocument}
              setSelectedChunkScore={setSelectedChunkScore}
            />
          ) : null}
          {isFetching.current && (
            // ... (ваш существующий блок "Retrieving..." / "Generating...")
          )}
    // ...
  );
};

export default ChatInterface;
Ключевые изменения в ChatInterface.tsx:

Новые состояния currentThinkText и currentMainText: Заменят previewText для раздельного сбора размышлений и основного текста.
isThinking useRef: Флаг для отслеживания, находимся ли мы внутри блока <think>. Используем useRef для isThinking, чтобы избежать бесконечного ререндера WebSocket.
collapseThinkBlock useState: Состояние для контроля автоматического сворачивания блока размышлений.
Улучшенная логика onmessage:
Проверяет newMessageContent на наличие <think> и </think>.
Управляет флагом isThinking.current.
Добавляет contentToProcess либо к currentThinkText, либо к currentMainText в зависимости от isThinking.current.
При обнаружении <think> setCollapseThinkBlock(false) разворачивает блок.
Формирование finalMessageContent: Когда генерация заканчивается (finish_reason === "stop"), мы собираем currentThinkText и currentMainText в одну строку. Если currentThinkText существует, мы вновь оборачиваем его в <think> теги для последующей обработки в ChatMessage.tsx (это важно для того, чтобы ChatMessage.tsx мог повторно распарсить и стилизовать).
Новое свойство autoCollapseThink в Message: Передается в ChatMessage для управления автоматическим сворачиванием.
Условный рендеринг ChatMessage для стриминга: Теперь ChatMessage рендерится, если есть currentThinkText или currentMainText, и получает их как отдельные пропсы (мы будем использовать message.thinkContent и message.content в ChatMessage).
Сброс состояний: При завершении или ошибке, currentThinkText и currentMainText сбрасываются.
Зависимости useEffect: Добавлены currentThinkText и currentMainText к зависимостям useEffect WebSocket для корректного закрытия и повторного открытия сокета при их изменении. Это может быть проблемой для производительности. Если будут проблемы, возможно, придется пересмотреть, как обновляется previewText во время стриминга.
Шаг 2: Модификация src/app/types.ts (или аналогичного файла, где определен Message)
Вам нужно будет добавить thinkContent и autoCollapseThink в интерфейс Message, чтобы TypeScript не ругался.

TypeScript

// app/types.ts (или где у вас определен интерфейс Message)

export interface Message {
  type: "user" | "system" | "error" | "retrieval";
  content: string | Document[];
  cached?: boolean;
  distance?: number;
  context?: string;
  thinkContent?: string; // НОВОЕ ПОЛЕ: для содержимого размышлений
  autoCollapseThink?: boolean; // НОВОЕ ПОЛЕ: флаг для автоматического сворачивания
}
Шаг 3: Изменения в ChatMessage.tsx
Теперь ChatMessage.tsx будет получать thinkContent и autoCollapseThink через message и будет управлять собственным состоянием сворачивания.

TypeScript

// ChatMessage.tsx
"use client";

import React, { useState, useEffect } from "react"; // Добавляем useEffect
import { ChunkScore, Message } from "@/app/types";
import ReactMarkdown from "react-markdown";
import { FaDatabase } from "react-icons/fa";
import { BiError } from "react-icons/bi";
import { IoNewspaper } from "react-icons/io5";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { IoDocumentAttach } from "react-icons/io5";
import { IoChevronDown, IoChevronUp } from "react-icons/io5"; // Импортируем иконки для сворачивания
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/cjs/styles/prism";

import VerbaButton from "../Navigation/VerbaButton";

import { Theme } from "@/app/types";

interface ChatMessageProps {
  message: Message;
  message_index: number;
  selectedTheme: Theme;
  selectedDocument: string | null;
  setSelectedDocument: (s: string | null) => void;
  setSelectedDocumentScore: (s: string | null) => void;
  setSelectedChunkScore: (s: ChunkScore[]) => void;
}

const ChatMessage: React.FC<ChatMessageProps> = ({
  message,
  selectedTheme,
  selectedDocument,
  setSelectedDocument,
  message_index,
  setSelectedDocumentScore,
  setSelectedChunkScore,
}) => {
  const colorTable = {
    user: "bg-bg-verba",
    system: "bg-bg-alt-verba",
    error: "bg-warning-verba",
    retrieval: "bg-bg-verba",
  };

  // Состояние для управления сворачиванием/разворачиванием блока размышлений
  const [isThinkBlockCollapsed, setIsThinkBlockCollapsed] = useState(true);

  // useEffect для автоматического сворачивания, когда message.autoCollapseThink становится true
  useEffect(() => {
    if (message.autoCollapseThink === true && !isThinkBlockCollapsed) {
      setIsThinkBlockCollapsed(true);
    }
    // Если размышления начинаются, разворачиваем блок
    if (message.type === "system" && message.thinkContent && message.thinkContent.length > 0 && isThinkBlockCollapsed) {
      setIsThinkBlockCollapsed(false);
    }
  }, [message.autoCollapseThink, isThinkBlockCollapsed, message.thinkContent, message.type]);


  if (typeof message.content === "string") {
    // В ChatMessage мы теперь ожидаем, что thinkContent и content
    // придут уже разделенными из ChatInterface, либо content будет содержать
    // оба, и мы его распарсим, если thinkContent не передан.

    let displayedContent = message.content;
    let thinkContent: string | null = message.thinkContent || null; // Предпочтительно использовать message.thinkContent

    // Если thinkContent не был передан отдельно (для старых сообщений или fallback)
    // мы можем попробовать распарсить его здесь.
    // Однако, для стриминга, ChatInterface должен передавать его отдельно.
    if (!thinkContent) {
      const thinkRegex = /<think>(.*?)<\/think>/s;
      const match = message.content.match(thinkRegex);
      if (match && match[1]) {
        thinkContent = match[1].trim();
        displayedContent = message.content.replace(thinkRegex, '').trim();
      }
    }


    return (
      <div
        className={`flex items-end gap-2 ${message.type === "user" ? "justify-end" : "justify-start"}`}
      >
        <div
          className={`flex flex-col items-start p-5 rounded-3xl animate-press-in text-sm lg:text-base ${colorTable[message.type]}`}
        >
          {message.cached && (
            <FaDatabase size={12} className="text-text-verba" />
          )}
          {message.type === "system" && (
            <>
              {thinkContent && (
                <div className="bg-bg-verba text-text-alt-verba p-3 rounded-lg mb-3 w-full border border-dashed border-text-alt-verba/30">
                  <div className="flex justify-between items-center cursor-pointer" onClick={() => setIsThinkBlockCollapsed(!isThinkBlockCollapsed)}>
                    <p className="font-semibold text-xs">Размышления:</p>
                    {isThinkBlockCollapsed ? <IoChevronDown size={15} /> : <IoChevronUp size={15} />}
                  </div>
                  {!isThinkBlockCollapsed && (
                    <ReactMarkdown className="prose md:prose-sm lg:prose-base prose-pre:bg-bg-alt-verba pt-2">
                      {thinkContent}
                    </ReactMarkdown>
                  )}
                </div>
              )}
              <ReactMarkdown
                className="prose md:prose-sm lg:prose-base p-3 prose-pre:bg-bg-alt-verba"
                components={{
                  code({ node, inline, className, children, ...props }) {
                    const match = /language-(\w+)/.exec(className || "");
                    return !inline && match ? (
                      <SyntaxHighlighter
                        style={
                          selectedTheme.theme === "dark"
                            ? (oneDark as any)
                            : (oneLight as any)
                        }
                        language={match[1]}
                        PreTag="div"
                        {...props}
                      >
                        {String(children).replace(/\n$/, "")}
                      </SyntaxHighlighter>
                    ) : (
                      <code className={className} {...props}>
                        {children}
                      </code>
                    );
                  },
                }}
              >
                {displayedContent}
              </ReactMarkdown>
            </>
          )}
          {message.type === "user" && (
            <div className="whitespace-pre-wrap">{message.content}</div>
          )}
          {message.type === "error" && (
            <div className="whitespace-pre-wrap flex items-center gap-2 text-sm text-text-verba">
              <BiError size={15} />
              <p>{message.content}</p>
            </div>
          )}
        </div>
      </div>
    );
  } else {
    // Остальная часть компонента без изменений
    return (
      <div className="grid grid-cols-2 lg:grid-cols-3 gap-3 w-full items-center">
        {message.content.map((document, index) => (
          <button
            onClick={() => {
              setSelectedDocument(document.uuid);
              setSelectedDocumentScore(
                document.uuid + document.score + document.chunks.length
              );
              setSelectedChunkScore(document.chunks);
            }}
            key={"Retrieval" + document.title + index}
            className={`flex ${selectedDocument && selectedDocument === document.uuid + document.score + document.chunks.length ? "bg-secondary-verba hover:bg-button-hover-verba" : "bg-button-verba hover:bg-secondary-verba"} rounded-3xl p-3 items-center justify-between transition-colors duration-300 ease-in-out border-none`}
          >
            <div className="flex items-center justify-between w-full">
              <p
                className="text-xs flex-grow truncate mr-2"
                title={document.title}
              >
                {document.title}
              </p>
              <div className="flex gap-1 items-center text-text-verba flex-shrink-0">
                <IoNewspaper size={12} />
                <p className="text-sm">{document.chunks.length}</p>
              </div>
            </div>
          </button>
        ))}
        <VerbaButton
          Icon={IoDocumentAttach}
          className="btn-sm btn-square"
          onClick={() =>
            (
              document.getElementById(
                "context-modal-" + message_index
              ) as HTMLDialogElement
            ).showModal()
          }
        />
        <dialog id={"context-modal-" + message_index} className="modal">
          <div className="modal-box">
            <h3 className="font-bold text-lg">Context</h3>
            <p className="py-4">{message.context}</p>
            <div className="modal-action">
              <form method="dialog">
                <button className="btn focus:outline-none text-text-alt-verba bg-button-verba hover:bg-button-hover-verba hover:text-text-verba border-none shadow-none">
                  <p>Close</p>
                </button>
              </form>
            </div>
          </div>
        </dialog>
      </div>
    );
  }
};

export default ChatMessage;
Ключевые изменения в ChatMessage.tsx:

Состояние isThinkBlockCollapsed: Управляет видимостью содержимого размышлений. Инициализируется как true (свернуто).
useEffect для autoCollapseThink и динамического сворачивания/разворачивания:
Когда message.autoCollapseThink становится true, и блок в данный момент развернут, он автоматически сворачивается.
Когда message.thinkContent начинает появляться (длина больше 0), и блок в данный момент свернут, он автоматически разворачивается.
Обработка thinkContent: Теперь ChatMessage предполагает, что message.thinkContent уже будет содержать текст размышлений, переданный из ChatInterface.tsx. Если его нет, он попытается распарсить message.content как резервный вариант (для совместимости со старыми сообщениями или если ChatInterface не был изменен).
Кнопка сворачивания/разворачивания: Добавлен div с onClick, который переключает isThinkBlockCollapsed. Иконки IoChevronDown и IoChevronUp изменяются в зависимости от состояния.
Условный рендеринг содержимого размышлений: <ReactMarkdown>{thinkContent}</ReactMarkdown> теперь находится внутри {!isThinkBlockCollapsed && (...) }, что означает, что он будет рендериться только тогда, когда блок развернут.
Шаг 4: Обновление зависимостей (если нужно)
Убедитесь, что у вас установлены иконки react-icons. Если нет, установите:

Bash

npm install react-icons # или yarn add react-icons
