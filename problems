Я понял вашу логику работы: сначала выбирается документ, затем вводится шаблон МЕМО, и отправляется запрос на формирование. Извините, что мои предыдущие объяснения были сосредоточены на message.content – это было связано с предыдущей ошибкой компиляции, которую вы прислали.

Ваша текущая проблема "Он все еще не предлагает загруженные документы в списке. Сейчас список пустой, хотя документы уже загружены" означает, что компонент, который должен отображать список документов (вероятно, DocumentExplorer, который используется внутри MEMOView.tsx), не получает данные о загруженных документах.

Проанализировав предоставленные вами файлы (api.py, managers.py, api.ts, types.ts), я не нашел явного API-эндпоинта или функции на фронтенде, которые бы запрашивали полный список всех загруженных документов (только их метаданные, такие как название и UUID) из Weaviate. Существующие эндпоинты в api.py предназначены для получения предложений (get_all_suggestions) или конкретного документа по UUID (get_document).

Чтобы решить эту проблему, нам нужно выполнить следующие шаги:

Создать новый метод в managers.py, который будет запрашивать из Weaviate метаданные всех загруженных документов (UUID и название).

Создать новый эндпоинт в api.py, который будет вызывать этот новый метод и возвращать список документов на фронтенд.

Создать новую функцию в api.ts, которая будет вызывать этот новый эндпоинт.

Изменить MEMOView.tsx (или MEMOInterface.tsx), чтобы он вызывал эту новую функцию при загрузке и обновлял состояние documentFilter, которое затем передается в DocumentExplorer.

Начнем с бэкенда.

Шаг 1: Обновление managers.py

Добавьте новый метод retrieve_all_documents_metadata в класс, который управляет взаимодействием с Weaviate (скорее всего, это класс, содержащий weaviate_manager или похожий, который вы используете в api.py). Я предполагаю, что это класс WeaviateManager внутри verba_manager.

В goldenverba/verba_manager.py (или соответствующем файле, где находится WeaviateManager), добавьте следующий метод:

Python
# managers.py (или goldenverba/verba_manager.py)

import weaviate.classes.query as wq
from goldenverba.components.document import Document # Убедитесь, что этот импорт есть

class WeaviateManager: # Убедитесь, что это правильный класс
    # ... (существующие методы) ...

    async def retrieve_all_documents_metadata(self, client: WeaviateAsyncClient, limit: int = 1000) -> list[dict]:
        """
        Retrieves metadata (UUID and title) for all documents from Weaviate.
        """
        try:
            documents_collection = client.collections.get("Document") # Убедитесь, что имя коллекции "Document"
            
            # Запрос всех документов, выбирая только UUID и название
            response = documents_collection.query.fetch_objects(
                limit=limit,
                return_properties=["doc_uuid", "title"], # Предполагаемые имена свойств в Weaviate
            )
            
            all_documents_metadata = []
            for obj in response.objects:
                if obj.properties and "doc_uuid" in obj.properties and "title" in obj.properties:
                    all_documents_metadata.append({
                        "uuid": obj.properties["doc_uuid"],
                        "title": obj.properties["title"],
                    })
            return all_documents_metadata
        except Exception as e:
            msg.fail(f"Error retrieving all document metadata from Weaviate: {e}")
            return []

Важное примечание:

Убедитесь, что имя вашей коллекции документов в Weaviate действительно "Document". Если нет, измените client.collections.get("Document") на правильное имя.

Я предположил, что UUID документа хранится в свойстве doc_uuid и название в свойстве title в вашей схеме Weaviate. Если у вас другие имена свойств (например, uuid вместо doc_uuid), измените return_properties=["doc_uuid", "title"] и доступ к obj.properties соответствующим образом.

Шаг 2: Обновление api.py

Добавьте новый эндпоинт /api/get_all_documents_metadata, который будет использовать новый метод из managers.py.

Python
# api.py

from goldenverba.server.types import DocumentFilter # Убедитесь, что DocumentFilter импортирован
from pydantic import BaseModel # Убедитесь, что BaseModel импортирован

# ... (существующие импорты и код) ...

# Добавьте этот класс полезной нагрузки для запроса документов
class GetAllDocumentsMetadataPayload(BaseModel):
    credentials: Credentials

# Добавьте этот эндпоинт
@app.post("/api/get_all_documents_metadata")
async def get_all_documents_metadata(payload: GetAllDocumentsMetadataPayload):
    try:
        client = await client_manager.connect(payload.credentials)
        documents_metadata = await manager.weaviate_manager.retrieve_all_documents_metadata(client)
        return JSONResponse(
            content={
                "documents": documents_metadata,
            }
        )
    except Exception as e:
        msg.fail(f"Error getting all document metadata: {e}")
        return JSONResponse(
            content={
                "documents": [],
            },
            status_code=500
        )

Шаг 3: Обновление types.ts (если требуется)

Убедитесь, что в types.ts есть тип для ответа API GetAllDocumentsMetadataPayload и DocumentFilter (который вы уже предоставили):

TypeScript
// types.ts

export type DocumentFilter = {
  title: string;
  uuid: string;
};

export type AllDocumentsMetadataResponse = {
  documents: DocumentFilter[];
};

// ... (остальные типы) ...
Шаг 4: Обновление api.ts

Добавьте новую функцию fetchAllDocumentsMetadata для вызова нового эндпоинта.

TypeScript
// api.ts

import {
  Credentials,
  DocumentFilter, // Убедитесь, что DocumentFilter импортирован
  AllDocumentsMetadataResponse, // Импортируйте новый тип
} from "./types";

// ... (существующие функции и импорты) ...

export const fetchAllDocumentsMetadata = async (
  credentials: Credentials
): Promise<AllDocumentsMetadataResponse | null> => {
  try {
    const host = await detectHost();
    const response = await fetch(`${host}/api/get_all_documents_metadata`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        credentials: credentials,
      }),
    });

    if (!response.ok) {
      console.error(
        `Error ${response.status}: Failed to fetch all document metadata.`
      );
      return null;
    }

    const data: AllDocumentsMetadataResponse = await response.json();
    return data;
  } catch (error) {
    console.error("Error fetching all document metadata:", error);
    return null;
  }
};

После внесения этих изменений, следующим шагом будет изменение MEMOView.tsx или MEMOInterface.tsx для использования этой новой функции и отображения документов.
Я бы рекомендовал начать с реализации этих изменений на бэкенде и в api.ts, а затем проверить, работает ли новый эндпоинт (например, с помощью Postman или curl), прежде чем переходить к изменениям на фронтенде.

Сообщите мне, когда вы будете готовы, и мы перейдем к изменениям на фронтенде.
